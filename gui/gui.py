
"""
bbss - BBS Student Management

Default graphical user interface for bbss.

Main window was generated by calling:
    pyuic5 bbss_tabbed_gui.ui > main.py

Created on Mon Feb  23 15:08:56 2014

@author: Christian Wichmann
"""

import os
import sys
import logging

from PyQt5 import QtGui
from PyQt5 import QtCore
from PyQt5 import QtWidgets

from gui.main import Ui_BBSS_Main_Window
from bbss import bbss


__all__ = ['start_gui']


logger = logging.getLogger('bbss.gui')


APP_NAME = "BBSS"


class StudentTableFilterProxyModel(QtCore.QSortFilterProxyModel):
    """Filters student table for regular expression in all columns."""
    def filterAcceptsRow(self, sourceRow, sourceParent):
        index0 = self.sourceModel().index(sourceRow, 0, sourceParent)
        index1 = self.sourceModel().index(sourceRow, 1, sourceParent)
        index2 = self.sourceModel().index(sourceRow, 2, sourceParent)
        return (self.filterRegExp().indexIn(self.sourceModel().data(index0)) >= 0
                or self.filterRegExp().indexIn(self.sourceModel().data(index1)) >= 0
                or self.filterRegExp().indexIn(self.sourceModel().data(index2)) >= 0)


class StudentTableModel(QtCore.QAbstractTableModel):
    def __init__(self, student_list, parent=None):
        super(StudentTableModel, self).__init__()
        self.student_list = student_list
        self.column_list = ('surname', 'firstname', 'classname', 'birthday')
        self.column_list_i18n = ('Nachname', 'Vorname', 'Klasse', 'Geburtstag')

    def update(self, student_list):
        self.student_list = student_list
        self.layoutChanged.emit()

    def rowCount(self, parent=QtCore.QModelIndex()):
        return len(self.student_list)

    def columnCount(self, parent=QtCore.QModelIndex()):
        return len(self.column_list)

    def data(self, index, role=QtCore.Qt.DisplayRole):
        if not index.isValid():
            return ''
        elif role != QtCore.Qt.DisplayRole:
            return None
        student = self.student_list[index.row()]
        return '{0}'.format(getattr(student, self.column_list[index.column()]))

    def student_data(self, index, role=QtCore.Qt.DisplayRole):
        student = self.student_list[index.row()]
        return student

    def headerData(self, count, orientation, role):
        if role == QtCore.Qt.DisplayRole:
            if orientation == QtCore.Qt.Horizontal:
                return self.column_list_i18n[count]
            elif orientation == QtCore.Qt.Vertical:
                return str(count+1)

    def setData(self, index, value, role=QtCore.Qt.DisplayRole):
        logger.warn('Updating of student data (row={row}, column={column}) not yet implemented.'.format(row=index.row(), column=index.column()))

    def flags(self, index):
        # TODO: Check whether data should be editable (QtCore.Qt.ItemIsEditable)?
        return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable


class BbssGui(QtWidgets.QMainWindow, Ui_BBSS_Main_Window):
    """Main window for bbss"""
    def __init__(self, parent=None):
        """Initialize main window for bbss."""
        logger.info('Building main window of bbss...')
        QtWidgets.QMainWindow.__init__(self, parent)
        self.FILENAME = ''
        self.setupUi(self)
        self.setup_table_models()
        self.setup_combo_boxes()
        self.center_on_screen()
        self.set_signals_and_slots()
        self.search_students_tableView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.search_students_tableView.customContextMenuRequested.connect(self.show_context_menu)

    def show_context_menu(self, pos):
        menu = QtWidgets.QMenu(self)
        copy_action = QtWidgets.QAction(QtGui.QIcon(), 'Kopieren', self)
        #copy_action.triggered.connect(self.testfkt)
        menu.addAction(copy_action)
        history_action = QtWidgets.QAction(QtGui.QIcon(), 'Historie', self)
        menu.addAction(history_action)
        export_action = QtWidgets.QAction(QtGui.QIcon(), 'Exportieren...', self)
        menu.addAction(export_action)
        global_coordinates = self.search_students_tableView.mapToGlobal(pos)
        # show menu and wait synchronous for click (asynchronous call: menu.popup)
        action = menu.exec_(global_coordinates)
        if action == copy_action:
            model = self.search_students_tableView.model()
            index = self.search_students_tableView.indexAt(pos)
            if 0 <= index.row() < model.rowCount():
                student = model.student_data(index)
                clipboard = QtWidgets.QApplication.clipboard()
                clipboard.clear(mode=clipboard.Clipboard)
                copy_text = ','.join((student.firstname, student.surname, student.classname, student.user_id, student.password))
                clipboard.setText(copy_text, mode=clipboard.Clipboard)
        elif action == history_action:
            model = self.search_students_tableView.model()
            index = self.search_students_tableView.indexAt(pos)
            if 0 <= index.row() < model.rowCount():
                student = model.student_data(index)
                data = bbss.get_class_history(student.user_id)
                template = 'Klasse {} von {} bis {}'
                message = '\n'.join([template.format(d[0], d[1], d[2]) for d in data])
                QtWidgets.QMessageBox.information(self, 'Klassenhistorie',message, QtWidgets.QMessageBox.Ok)
        elif action == export_action:
            model = self.search_students_tableView.model()
            selected_rows = self.search_students_tableView.selectionModel().selectedRows()
            selected_students = [model.student_data(r) for r in selected_rows]
            output_file = QtWidgets.QFileDialog.getSaveFileName(self, 'Wähle PDF-Datei zum Export...', '', 'PDF-Datei (*.pdf)')[0]
            if output_file:
                bbss.export_pdf_file(output_file, selected_students)

    def setup_table_models(self):
        """Sets up table view and its models."""
        # set up import table view
        self.import_table_model = StudentTableModel(bbss.student_list)
        self.proxy_import_table_model = StudentTableFilterProxyModel()
        self.proxy_import_table_model.setSourceModel(self.import_table_model)
        self.proxy_import_table_model.setDynamicSortFilter(True)
        self.import_data_tableview.setModel(self.proxy_import_table_model)
        self.import_data_tableview.horizontalHeader().setSectionResizeMode (
            QtWidgets.QHeaderView.Stretch)
        # set up export table views
        self.added_students_table_model = StudentTableModel(list())
        self.removed_students_table_model = StudentTableModel(list())
        self.added_students_tableview.setModel(
            self.added_students_table_model)
        self.removed_students_tableview.setModel(
            self.removed_students_table_model)
        self.added_students_tableview.horizontalHeader().setSectionResizeMode (
            QtWidgets.QHeaderView.Stretch)
        self.removed_students_tableview.horizontalHeader().setSectionResizeMode (
            QtWidgets.QHeaderView.Stretch)
        # set up search table views
        self.search_students_table_model = StudentTableModel(list())
        self.search_students_tableView.setModel(self.search_students_table_model)
        self.search_students_tableView.horizontalHeader().setSectionResizeMode(
            QtWidgets.QHeaderView.Stretch)
        self.search_students_tableView.setSelectionBehavior(
            QtWidgets.QAbstractItemView.SelectRows)
        self.search_students_tableView.setSelectionMode(
            QtWidgets.QAbstractItemView.ExtendedSelection)

    def setup_combo_boxes(self):
        # TODO get values from bbss package
        export_formats = ('LogoDidact', 'Radius-Server', 'Active Directory',
                          'Moodle', 'WebUntis', 'LabSoft Classroom Manager')
        self.export_format_combobox.addItems(export_formats)

    def center_on_screen(self):
        """Centers the window on the screen."""
        screen = QtWidgets.QDesktopWidget().screenGeometry()
        size = self.geometry()
        self.move((screen.width() - size.width()) / 2,
                  (screen.height() - size.height()) / 2)

    def set_signals_and_slots(self):
        """Sets all signals and slots for main window."""
        self.import_data_button.clicked.connect(self.on_import_data)
        self.load_file_button.clicked.connect(self.on_load_file)
        self.delete_database_button.clicked.connect(self.on_delete_database)
        self.import_filter_text.textEdited.connect(self.on_import_filter)
        self.old_import_number.textEdited.connect(
            self.on_update_export_changeset)
        self.new_import_number.textEdited.connect(
            self.on_update_export_changeset)
        self.export_data_button.clicked.connect(self.on_export_data)
        self.search_student_text.textEdited.connect(self.on_search_student)
        self.search_students_tableView.selectionModel().selectionChanged.connect(
            self.on_select_student_from_search)
        self.TaskTabbedPane.currentChanged.connect(self.on_tab_changed)
        self.menu_exit.triggered.connect(self.close)
        self.clear_search_field_button.clicked.connect(self.search_student_text.clear)
        # TODO Connect options check boxes with functions.
        #      (replace_classnames_checkbox, replace_characters_checkbox, store_in_db_checkbox)

    @QtCore.pyqtSlot()
    def on_load_file(self):
        logger.info('Loading file with student data...')
		# store only first element of tuple (new in PyQt5)
        self.FILENAME = QtWidgets.QFileDialog\
            .getOpenFileName(self, 'Öffne Schülerdatendatei...', '',
                             'BBS-Verwaltung (*.csv);;BBS-Planung (*.xls *.xlsx)')[0]
        logger.info('Student data file chosen: "{0}".'.format(self.FILENAME))
        _, ext = os.path.splitext(self.FILENAME)
        if ext == '.csv':
            bbss.import_bbs_verwaltung_csv_file(self.FILENAME)
        elif ext == '.xls' or ext == '.xlsx':
            bbss.import_excel_file(self.FILENAME)
        else:
            logger.warn('Given file format can not be imported.')
        self.import_table_model.update(bbss.student_list)
        self.proxy_import_table_model.setSourceModel(self.import_table_model)
        self.import_data_tableview.resizeColumnsToContents()

    @QtCore.pyqtSlot()
    def on_import_data(self):
        logger.info('Importing data into database...')
        self.progress = QtWidgets.QProgressDialog('Importiere Schüler...',
                                                  'Abbrechen', 0, 0, self)
        self.progress.setWindowModality(QtCore.Qt.WindowModal)
        self.progress.canceled.connect(self.progress.close)
        self.progress.show()
        def update_progressbar(current, complete):
            self.progress.setRange(0, complete)
            self.progress.setValue(current+1)
        bbss.store_students_db(self.FILENAME, callback=update_progressbar)
        message = "Schülerdaten aus Datei {0} wurden erfolgreich eingelesen."\
                  .format(self.FILENAME)
        QtWidgets.QMessageBox.information(self, 'Schülerdaten importiert.',
                                          message, QtWidgets.QMessageBox.Ok)

    @QtCore.pyqtSlot()
    def on_delete_database(self):
        logger.info('Deleting database file...')
        message = "Soll die Datenbankdatei wirklich gelöscht werden? "\
                  "Alle gespeicherten Informationen gehen dabei verloren!"
        reply = QtWidgets.QMessageBox.question(self, 'Datenbank löschen?',
                                               message, QtWidgets.QMessageBox.Yes,
                                               QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            bbss.clear_database()

    @QtCore.pyqtSlot(str)
    def on_import_filter(self, filter_string):
        if filter_string:
            logger.debug('Filtering for {0}...'.format(filter_string))
            syntax = QtCore.QRegExp.PatternSyntax(QtCore.QRegExp.Wildcard)
            case_sensitivity = QtCore.Qt.CaseInsensitive
            regExp = QtCore.QRegExp(filter_string, case_sensitivity, syntax)
            self.proxy_import_table_model.setFilterRegExp(regExp)
            count = self.proxy_import_table_model.rowCount()
            self.search_result_label.setText('{} Schüler gefunden...'.format(count))
        else:
            self.search_result_label.setText('')

    @QtCore.pyqtSlot(str)
    def on_search_student(self, search_string):
        """Search database each time the search text field was edited. The
        result is shown in the search table view.
        """
        logger.debug('Searching for "{}"...'.format(search_string))
        result = bbss.search_student_in_database(search_string)
        self.search_students_table_model.update(result)

    @QtCore.pyqtSlot(QtCore.QItemSelection, QtCore.QItemSelection)
    def on_select_student_from_search(self, selected, deselected):
        """Show student information in text boxes when student was selected in
        search table view."""
        if selected:
            # get selected student from model
            model_index = selected[0].topLeft()
            selected_student = self.search_students_table_model.student_data(model_index)
            # fill in text boxes with student information
            self.result_username_text.setText(selected_student.user_id)
            imports = [str(i) for i in bbss.get_imports_for_student(selected_student)]
            self.result_imports_text.setText(', '.join(imports) + 
                                             ' - GUID: {}'.format(selected_student.guid))
            self.result_birthday_text.setText(selected_student.birthday)
            self.result_name_text.setText(selected_student.firstname)
            self.result_class_text.setText(selected_student.classname)
            self.result_password_text.setText(selected_student.password)
            self.result_surname_text.setText(selected_student.surname)

    @QtCore.pyqtSlot()
    def on_update_export_changeset(self):
        self.update_changeset_from_database()

    def update_changeset_from_database(self):
        """Updates import IDs and changeset based on currently set values in
           user interface."""
        try:
            old_id = int(self.old_import_number.text())
        except:
            logger.warn('Import IDs must be integer values.')
            old_id = 0
        try:
            new_id = int(self.new_import_number.text())
        except:
            logger.warn('Import IDs must be integer values.')
            new_id = 0
        self.changeset = bbss.generate_changeset(old_import_id=old_id,
                                                 new_import_id=new_id)
        logger.debug('{} added, {} changed, {} removed'
                     .format(*self.changeset.get_statistics()))
        # update tables for added and removed students
        self.added_students_table_model = StudentTableModel(
            self.changeset.students_added)
        self.removed_students_table_model = StudentTableModel(
            self.changeset.students_removed)
        self.added_students_tableview.setModel(
            self.added_students_table_model)
        self.removed_students_tableview.setModel(
            self.removed_students_table_model)
        # update labels with student count
        self.added_student_table_label.setText('Hinzugefügte Schüler ({}):'
            .format(self.changeset.get_statistics().added))
        self.removed_student_table_label.setText('Entfernte Schüler ({}):'
            .format(self.changeset.get_statistics().removed))

    @QtCore.pyqtSlot()
    def on_export_data(self):
        self.update_changeset_from_database()
        export_format = self.export_format_combobox.currentText()
        # TODO: Ask for file name after evaluating export format!
        export_file = self.get_filename_for_export()
        if export_file:
            if export_format == 'LogoDidact':
                bbss.export_csv_file(export_file, self.changeset)
            elif export_format == 'Radius-Server':
                bbss.export_radius_file(export_file, self.changeset)
            elif export_format == 'Moodle':
                bbss.export_moodle_file(export_file, self.changeset)
            elif export_format == 'WebUntis':
                bbss.export_webuntis_file(export_file, self.changeset)
            elif export_format == 'LabSoft Classroom Manager':
                bbss.export_labsoft_file(export_file, self.changeset)
            else:
                logger.warn('Export format not yet implemented.')
                message = 'Gewünschtes Exportformat noch nicht implementiert.'
                QtWidgets.QMessageBox.information(self, 'Fehler bei Export',
                                                  message, QtWidgets.QMessageBox.Ok)

    def get_filename_for_export(self):
        """Gets filename for export of student data from user."""
        filename = QtWidgets.QFileDialog.getSaveFileName(self, 'Speichere Datei...')[0]
        logger.info('Export file chosen: "{0}".'.format(filename))
        return filename

    @QtCore.pyqtSlot()
    def on_tab_changed(self):
        if self.TaskTabbedPane.currentIndex() == 1:
            self.update_changeset_from_database()


def start_gui():
    # make app object global to let it be collected to prevent error messages
    # http://stackoverflow.com/questions/27131294/error-qobjectstarttimer-qtimer-can-only-be-used-with-threads-started-with-qt/27155799#27155799
    global app
    app = QtWidgets.QApplication(sys.argv)
    app.setApplicationName(APP_NAME)
    main = BbssGui()
    main.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    start_gui()
